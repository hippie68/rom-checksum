#!/bin/bash

# This script calculates SHA-1 checksums for ROM files and ROM files inside
# archives, ignoring ROM headers. Which is particularly useful to check for
# romhack compatibility.
# Currently only NES headers are ignored. Please let me know if there is demand
# for more headered file types.
# The script requires GNU coreutils and at least Bash 4.4.
# For archive support, the following programs are required:
# - unzip for .zip files
# - gunzip for .gz files
# - 7za for .7z files
# Project homepage: https://github.com/hippie68/rom-sha1sum

MAX_DECOMPRESSION_RECURSION_LVL=1 # Increase to parse deeply nested archives.
FILE_EXTENSIONS=(3ds gb gba gbc gcm gcz gen gg md n64 ngc ngp nds nes nez nsp pce sfc smc smd srl v64 vb vpk ws wsc xci xiso z64 zip gz 7z) # Note: additional archives must be handled in process_file().
IFS=\| FILE_EXT_REGEX="\\.(${FILE_EXTENSIONS[*]})\$"

print_usage() {
    echo "Usage: $(basename "$0") FILE/DIRECTORY [...]"
}

get_magic() {
    head --bytes=4 "$1" | tr -d '\000'
}

# $1: filename, $2: offset, $3: variable name
sha1sum_to_var() {
    local -n sha1=$3
    if [[ $2 -ne 0 ]]; then
        sha1=$(tail --bytes=+$(("$2" + 1)) "$1" | sha1sum)
    else
        sha1=$(sha1sum "$1")
    fi
    sha1=${sha1:0:40}
}

# $1: checksum, $2: filename, $3: suffix, $4: archive chain
print_checksum() {
    echo -n "$1  "
    echo -n "$2"
    [[ $3 ]] && echo -en " \033[1;32m$3\033[0m"
    [[ $4 ]] && echo -en " \033[1;30m$4\033[0m"
    echo
}

# Do sha1sum for file $1, but skip $2 bytes. $3: archive name
sha1sum_skip_n() {
    local sha1_full
    sha1sum_to_var "$1" 0 sha1_full
    local filename
    filename=$(basename "$1")
    if [[ $2 -gt 0 ]]; then
        local sha1_without_header
        sha1sum_to_var "$1" "$2" sha1_without_header
        print_checksum "$sha1_without_header" "$filename" "[-H]" "$3"
        print_checksum "$sha1_full"  "$filename" "[+H]" "$3"
    else
        print_checksum "$sha1_full" "$filename" "" "$3"
    fi
}

error() {
    echo -e "\033[1;31mERROR: \033[0m$1" >&2
}

# $1: filename, $2: recursion level
max_recursion_reached() {
    if [[ $2 -gt $MAX_DECOMPRESSION_RECURSION_LVL ]]; then
        error "Ignoring nested archive file (too many recursions): \"$1\""
        return 0
    fi
    return 1
}

create_archive_wildcards() {
    declare -ag ARCHIVE_FILE_WILDCARDS
    ARCHIVE_FILE_WILDCARDS=("${FILE_EXTENSIONS[@]}")
    for ((i = 0; i < ${#ARCHIVE_FILE_WILDCARDS[@]}; i++)) {
        ARCHIVE_FILE_WILDCARDS[i]="*?.${ARCHIVE_FILE_WILDCARDS[$i]}"
    }
}

# $1: current archive chain, $2: nested archive
update_archive_chain() {
    local -n chain=$1
    if [[ $chain ]]; then
        chain="< $(basename "$2") $chain"
    else
        chain="< $2"
    fi
}

# $1: filename, $2: recursion level, $3: archive chain
process_file() {
    local archive_chain=$3
    case $(get_magic "$1") in
        $'NES\x1a')
            sha1sum_skip_n "$1" 16 "$archive_chain"
            ;;
        $'PK\x03\x04') # ZIP
            max_recursion_reached "$1" "$2" && return
            [[ ! -v ARCHIVE_FILE_WILDCARDS ]] && create_archive_wildcards
            local tmp_dir
            tmp_dir=$(mktemp --directory) || exit 1
            unzip -d "$tmp_dir" "$1" "${ARCHIVE_FILE_WILDCARDS[@]}" &> /dev/null
            local ret=$?
            if [[ $ret -eq 0 || $ret -eq 11 ]]; then
                update_archive_chain archive_chain "$1"
                readarray -d '' < <(find "$tmp_dir" -type f -print0)
                for file in "${MAPFILE[@]}"; do
                    process_file "$file" $(($2 + 1)) "$archive_chain"
                done
            else
                error "Could not extract ZIP file \"$1\""
            fi
            rm -r "$tmp_dir" || exit 1
            ;;
        $'\x1f\x8b'*) # gzip
            max_recursion_reached "$1" "$2" && return
            local tmp_dir
            tmp_dir=$(mktemp --directory) || exit 1
            tmp_file="$tmp_dir/${1%.gz}"
            if gunzip --to-stdout "$1" > "$tmp_file"; then
                update_archive_chain archive_chain "$1"
                process_file "$tmp_file" $(($2 + 1)) "$archive_chain"
            else
                error "Could not extract gzip file \"$1\""
            fi
            rm -r "$tmp_dir" || exit 1
            ;;
        $'7z\xbc\xaf')
            max_recursion_reached "$1" "$2" && return
            [[ ! -v ARCHIVE_FILE_WILDCARDS ]] && create_archive_wildcards
            local tmp_dir
            tmp_dir=$(mktemp --directory) || exit 1
            if 7za x -o"$tmp_dir" "$1" "${ARCHIVE_FILE_WILDCARDS[@]}" > /dev/null; then
                update_archive_chain archive_chain "$1"
                readarray -d '' < <(find "$tmp_dir" -type f -print0)
                for file in "${MAPFILE[@]}"; do
                    process_file "$file" $(($2 + 1)) "$archive_chain"
                done
            else
                error "Could not extract 7-Zip file \"$1\""
            fi
            rm -r "$tmp_dir" || exit 1
            ;;
        *)
            shopt -s nocasematch
            if [[ $1 =~ $FILE_EXT_REGEX ]]; then
                [[ $1 == *.md ]] && [[ $(file "$1") == *text* ]] && return
                sha1sum_skip_n "$1" 0 "$3"
            else
                error "Unknown file extension: \"$1\""
            fi
            shopt -u nocasematch
            ;;
    esac
}

if [[ ! $1 ]]; then
    print_usage
    exit 0
fi

parse_file() {
    if [[ -d $1 ]]; then
        readarray -d '' files < <(find "$1" -type f -regextype posix-extended -regex ".*$FILE_EXT_REGEX" -print0)
        for f in "${files[@]}"; do
            parse_file "$f"
        done
    elif [[ ! -f $1 ]]; then
        error "Not a file: \"$1\""
    else
        process_file "$1" 0
    fi
}

for file in "$@"; do
    parse_file "$file"
done
